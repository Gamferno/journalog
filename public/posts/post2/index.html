<!doctype html>







<html
  class="not-ready lg:text-base"
  style="--bg:#faf8f1"
  lang="en-us"
  dir="ltr"
><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, shrink-to-fit=no"
  />

  
  <title>TIL : Rust Ownership &#43; Typescript Basics - Journalog</title>

  
  <meta name="theme-color" />

  <meta name="description" content="üå± Summary
Today i studied Rust Ownership concepts -&gt; References and Ownerships &amp; Borrowing and intro to Typescript

üìì Journal / Notes
In Rust, yesterday i read the intro to ownership from the rust book, in very brief if i have to tell Ownership s ensuring safety of Rust programs, that means avoiding any runtime errors by fixing it right now, like if something is read now and used later like a variable, this could cause a &ldquo;undefined behaviour&rdquo; which rust gives out error on, rust ensures memory safety by avoiding this undefine behaviour and catching them which compiling, unlike runtime languages like javascript or python, where the compiler once or twice may run the faulty code but this may left unnoticed and the may cause issues for the user after deployment" />
  <meta name="author" content="Om Pathak" /><link rel="preload stylesheet" as="style" href="https://gamferno.github.io/journalog/main.min.css" />

  
  <link rel="preload" as="image" href="https://gamferno.github.io/journalog/theme.png" />

  <link rel="preload" as="image" href="https://www.gravatar.com/avatar/b9c60c516b2c9bf913d6e2d1b4cf7f1f?s=160&amp;d=identicon" />

  <link rel="preload" as="image" href="https://gamferno.github.io/journalog/twitter.svg" /><link rel="preload" as="image" href="https://gamferno.github.io/journalog/github.svg" />

  <script
    defer
    src="https://gamferno.github.io/journalog/highlight.min.js"
    onload="hljs.initHighlightingOnLoad();"
  ></script>

  
  <link
    rel="icon"
    href="https://gamferno.github.io/journalog/favicon.ico"
  />
  <link
    rel="apple-touch-icon"
    href="https://gamferno.github.io/journalog/apple-touch-icon.png"
  />

  <meta name="generator" content="Hugo 0.148.2">
  <meta itemprop="name" content="TIL : Rust Ownership &#43; Typescript Basics">
  <meta itemprop="description" content="üå± Summary Today i studied Rust Ownership concepts -&gt; References and Ownerships &amp; Borrowing and intro to Typescript
üìì Journal / Notes In Rust, yesterday i read the intro to ownership from the rust book, in very brief if i have to tell Ownership s ensuring safety of Rust programs, that means avoiding any runtime errors by fixing it right now, like if something is read now and used later like a variable, this could cause a ‚Äúundefined behaviour‚Äù which rust gives out error on, rust ensures memory safety by avoiding this undefine behaviour and catching them which compiling, unlike runtime languages like javascript or python, where the compiler once or twice may run the faulty code but this may left unnoticed and the may cause issues for the user after deployment">
  <meta itemprop="datePublished" content="2025-08-18T00:00:00+00:00">
  <meta itemprop="dateModified" content="2025-08-18T00:00:00+00:00">
  <meta itemprop="wordCount" content="687"><meta property="og:url" content="https://gamferno.github.io/journalog/posts/post2/">
  <meta property="og:site_name" content="Journalog">
  <meta property="og:title" content="TIL : Rust Ownership &#43; Typescript Basics">
  <meta property="og:description" content="üå± Summary Today i studied Rust Ownership concepts -&gt; References and Ownerships &amp; Borrowing and intro to Typescript
üìì Journal / Notes In Rust, yesterday i read the intro to ownership from the rust book, in very brief if i have to tell Ownership s ensuring safety of Rust programs, that means avoiding any runtime errors by fixing it right now, like if something is read now and used later like a variable, this could cause a ‚Äúundefined behaviour‚Äù which rust gives out error on, rust ensures memory safety by avoiding this undefine behaviour and catching them which compiling, unlike runtime languages like javascript or python, where the compiler once or twice may run the faulty code but this may left unnoticed and the may cause issues for the user after deployment">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-08-18T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-08-18T00:00:00+00:00">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="TIL : Rust Ownership &#43; Typescript Basics">
  <meta name="twitter:description" content="üå± Summary Today i studied Rust Ownership concepts -&gt; References and Ownerships &amp; Borrowing and intro to Typescript
üìì Journal / Notes In Rust, yesterday i read the intro to ownership from the rust book, in very brief if i have to tell Ownership s ensuring safety of Rust programs, that means avoiding any runtime errors by fixing it right now, like if something is read now and used later like a variable, this could cause a ‚Äúundefined behaviour‚Äù which rust gives out error on, rust ensures memory safety by avoiding this undefine behaviour and catching them which compiling, unlike runtime languages like javascript or python, where the compiler once or twice may run the faulty code but this may left unnoticed and the may cause issues for the user after deployment">

  <link rel="canonical" href="https://gamferno.github.io/journalog/posts/post2/" />
</head>
<body
    class="bg-(--bg) text-black antialiased duration-200 ease-out [-webkit-tap-highlight-color:transparent] dark:text-white"
  ><header
  class="mx-auto flex h-[4.5rem] max-w-(--w) px-8 whitespace-nowrap lg:justify-center"
>
  <div class="relative z-50 flex items-center ltr:mr-auto rtl:ml-auto">
    <a
      class="-translate-y-[1px] text-2xl font-medium"
      href="https://gamferno.github.io/journalog/"
      >Journalog</a
    >
    <div
      class="btn-dark text-[0px] ltr:ml-4 rtl:mr-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]"
      role="button"
      aria-label="Dark"
    ></div>
  </div>

  <div
    class="btn-menu relative z-50 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden ltr:-mr-8 rtl:-ml-8"
    role="button"
    aria-label="Menu"
  ></div>

  <script>
    
    const htmlClass = document.documentElement.classList;
    setTimeout(() => {
      htmlClass.remove('not-ready');
    }, 10);

    
    const btnMenu = document.querySelector('.btn-menu');
    btnMenu.addEventListener('click', () => {
      htmlClass.toggle('open');
    });

    
    const metaTheme = document.querySelector('meta[name="theme-color"]');
    const lightBg = '#faf8f1'.replace(/"/g, '');
    const setDark = (isDark) => {
      metaTheme.setAttribute('content', isDark ? '#000' : lightBg);
      htmlClass[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark);
    };

    
    const darkScheme = window.matchMedia('(prefers-color-scheme: dark)');
    if (htmlClass.contains('dark')) {
      setDark(true);
    } else {
      const darkVal = localStorage.getItem('dark');
      setDark(darkVal ? darkVal === 'true' : darkScheme.matches);
    }

    
    darkScheme.addEventListener('change', (event) => {
      setDark(event.matches);
    });

    
    const btnDark = document.querySelector('.btn-dark');
    btnDark.addEventListener('click', () => {
      setDark(localStorage.getItem('dark') !== 'true');
    });
  </script>

  <div
    class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full flex-col justify-center bg-(--bg) pb-16 duration-200 select-none lg:static lg:h-auto lg:flex-row lg:bg-transparent! lg:pb-0 lg:transition-none"
  ><nav
      class="lg:ml-12 lg:flex lg:flex-row lg:items-center lg:space-x-10 rtl:space-x-reverse"
    ><a
        class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal"
        href="/journalog/about/"
        >About</a
      ></nav><nav
      class="mt-12 flex justify-center space-x-10 lg:mt-0 lg:items-center ltr:lg:ml-14 rtl:space-x-reverse rtl:lg:mr-14 dark:invert"
    >
      <a
        class="h-7 w-7 text-[0px] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./twitter.svg)"
        href="https://twitter.com/om__pathak"
        target="_blank"
        rel="me"
      >twitter</a>
      <a
        class="h-7 w-7 text-[0px] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./github.svg)"
        href="https://github.com/gamferno"
        target="_blank"
        rel="me"
      >github</a>
    </nav>
  </div>
</header>
<main
      class="prose prose-neutral dark:prose-invert relative mx-auto min-h-[calc(100vh-9rem)] max-w-(--w) px-8 pt-14 pb-16"
    ><article>
  <header class="mb-14">
    <h1 class="my-0! pb-2.5">TIL : Rust Ownership &#43; Typescript Basics</h1><div class="text-xs antialiased opacity-60"><time>Aug 18, 2025</time></div></header>

  <section><h2 id="-summary">üå± Summary</h2>
<p>Today i studied Rust Ownership concepts -&gt; References and Ownerships &amp; Borrowing and intro to Typescript</p>
<hr>
<h2 id="-journal--notes">üìì Journal / Notes</h2>
<p>In Rust, yesterday i read the intro to ownership from the rust book, in very brief if i have to tell Ownership s ensuring safety of Rust programs, that means avoiding any runtime errors by fixing it right now, like if something is read now and used later like a variable, this could cause a &ldquo;undefined behaviour&rdquo; which rust gives out error on, rust ensures memory safety by avoiding this undefine behaviour and catching them which compiling, unlike runtime languages like javascript or python, where the compiler once or twice may run the faulty code but this may left unnoticed and the may cause issues for the user after deployment</p>
<p>Second, we learned that variables live in a frame and there could be multiple frames in a stack, a frame is just like a variable -&gt; value
now to store data in heap we use <strong>Box</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> Box::new([<span style="color:#ae81ff">0</span>; <span style="color:#ae81ff">1_000_000</span>]);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> b <span style="color:#f92672">=</span> a;
</span></span></code></pre></div><p>when we do this a gets copied onto b, but another thing happens, that is ownership of this box is transferred to b
Rust also doesnt let the user manage memory as that can lead to memory issues, like a user frees memory of a variable and tries to use it later</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> a_num <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>    make_and_drop();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">make_and_drop</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> a_box <span style="color:#f92672">=</span> Box::new(<span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>here initially a_num -&gt; 4 is stored in stack, when function is called a_box -&gt; heap(5), and then when function is over, rust deallocates this function and the variables inside and in the stack, only a_num -&gt; 4 remains</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> first <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;Ferris&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> full <span style="color:#f92672">=</span> add_suffix(first);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">println!</span>(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{full}</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">add_suffix</span>(<span style="color:#66d9ef">mut</span> name: String) -&gt; String {
</span></span><span style="display:flex;"><span>    name.push_str(<span style="color:#e6db74">&#34; Jr.&#34;</span>);
</span></span><span style="display:flex;"><span>    name
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>here, initially first -&gt; heap(&ldquo;ferris&rdquo;), then full calls function add_suffix, now name owns the contents of first since this is not a reference it actually gives the ownership to name, so now first has now way to access this memory, name on pushing becomes heap(&ldquo;Ferris Jr&rdquo;)
and returns name, so now this function is finished, rust deaalocates memory and it returns the name string so now full owns this memory space so full -&gt; heap(&ldquo;Ferris Jr.&rdquo;)</p>
<p>Note that: you cant use first now since it points to nowhere, since on ownership transfer it lost it pointer to the memory</p>
<p>If you wish to avoid losing variables&rsquo;s ownership you can create a clone of the variable like</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> first <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;Ferris&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> full <span style="color:#f92672">=</span> add_suffix(first);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">println!</span>(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{full}</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">add_suffix</span>(<span style="color:#66d9ef">mut</span> name: String) -&gt; String {
</span></span><span style="display:flex;"><span>    name.push_str(<span style="color:#e6db74">&#34; Jr.&#34;</span>);
</span></span><span style="display:flex;"><span>    name
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now comes the most tough part, i only understood 50% of what is being said,</p>
<p>References and Borrowing!</p>
<p>like in example above the first variable lost its ownership when the function used it as a parameter and the finsihed and memory deallocated, instead we can pass the reference to the variable which stores address to the heap</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> m1 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;Hello&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> m2 <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;world&#34;</span>);
</span></span><span style="display:flex;"><span>    greet(<span style="color:#f92672">&amp;</span>m1, <span style="color:#f92672">&amp;</span>m2); <span style="color:#75715e">// note the ampersands
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> s <span style="color:#f92672">=</span> <span style="color:#a6e22e">format!</span>(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74"> </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, m1, m2);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">greet</span>(g1: <span style="color:#66d9ef">&amp;</span>String, g2: <span style="color:#66d9ef">&amp;</span>String) { <span style="color:#75715e">// note the ampersands
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">println!</span>(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74"> </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">!&#34;</span>, g1, g2);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>just pass the parameters when calling the function with a &lsquo;&amp;&rsquo; symbol and on type while defining function</p>
<p>now when this is called, m1 and m2 point to hello and world in heap, and g1 and g2 point to m1 and m2, and on deallocating m1 and m2 are safe</p>
<p>to define a variable dynamically you can</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> x : Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> Box::new(<span style="color:#ae81ff">1</span>);
</span></span></code></pre></div><p>to store value of this x on a variable you can dereference this pointer, just like in cpp</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> a: <span style="color:#66d9ef">i32</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;*&#39;</span>x; <span style="color:#75715e">// note that it is just aseterix i cant type it due to md considers asterix as syntax for bold
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#e6db74">&#39;*&#39;</span>x <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> r1 : <span style="color:#66d9ef">&amp;</span>Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>x;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> b : <span style="color:#66d9ef">i32</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">&#39;</span><span style="color:#f92672">**</span><span style="color:#a6e22e">&#39;r1</span>
</span></span></code></pre></div><h2 id="-thoughts">üí≠ Thoughts</h2>
<p>I am mostly understanding Rust and would hope to finish it in next week and start Solana</p>
</section>

  <nav
    class="mt-24 flex overflow-hidden rounded-xl bg-black/[3%] text-lg leading-[1.2]! *:flex *:w-1/2 *:items-center *:p-5 *:font-medium *:no-underline dark:bg-white/[8%] [&>*:hover]:bg-black/[2%] dark:[&>*:hover]:bg-white/[3%]"
  ><a
      class="justify-end pl-3 ltr:ml-auto rtl:mr-auto"
      href="https://gamferno.github.io/journalog/posts/post1/"
      ><span>TIL : Rust Basics</span><span class="ltr:ml-1.5 rtl:mr-1.5">‚Üí</span></a
    ></nav></article></main><footer
  class="mx-auto flex h-[4.5rem] max-w-(--w) items-center px-8 text-xs tracking-wider uppercase opacity-60"
>
  <div class="mr-auto">&copy;2025
    <a class="link" href="https://gamferno.github.io/journalog/">Journalog</a></div>
  <a class="link mx-6" href="https://gohugo.io/" rel="noopener" target="_blank"
    >powered by me</a
  >Ô∏è
  <a
    class="link"
    href="https://github.com/nanxiaobei/hugo-paper"
    rel="noopener"
    target="_blank"
    >om-pathak</a
  >
</footer>
</body>
</html>
